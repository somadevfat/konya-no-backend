# Simple Spring REST API - バックエンド詳細解説

**作成日時:** 2025年7月7日 13:07:01 JST

## 1. アプリケーション全体の構成

このアプリケーションは、**Spring Boot**を使った典型的な**3層アーキテクチャ**で構成されています。

```
┌─────────────────────────────────────────────────────────────┐
│                    フロントエンド                           │
│                 (HTML + JavaScript)                        │
└─────────────────────────────────────────────────────────────┘
                            ↓ HTTP リクエスト
┌─────────────────────────────────────────────────────────────┐
│                   コントローラー層                          │
│                (ArticleController.java)                    │
│              ・HTTPリクエストを受け取る                      │
│              ・レスポンスを返す                              │
└─────────────────────────────────────────────────────────────┘
                            ↓ メソッド呼び出し
┌─────────────────────────────────────────────────────────────┐
│                    サービス層                               │
│                 (ArticleService.java)                      │
│              ・ビジネスロジック                              │
│              ・データ処理のルール                            │
└─────────────────────────────────────────────────────────────┘
                            ↓ メソッド呼び出し
┌─────────────────────────────────────────────────────────────┐
│                  リポジトリ層                               │
│                (ArticleRepository.java)                    │
│              ・データベースアクセス                          │
│              ・CRUD操作                                     │
└─────────────────────────────────────────────────────────────┘
                            ↓ SQL クエリ
┌─────────────────────────────────────────────────────────────┐
│                    データベース                             │
│                    (H2 Database)                           │
│              ・実際のデータ保存                              │
└─────────────────────────────────────────────────────────────┘
```

## 2. 各クラスの詳細解説

### 2.1 Article.java (ドメインクラス)

```java
@Entity
@Data
public class Article {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String title;
    private String content;
}
```

**役割:** データベースのテーブル構造を表現する「設計図」

#### アノテーション解説
- `@Entity`: 「このクラスはデータベースのテーブルと対応しています」とSpringに伝える
- `@Data`: Lombokライブラリが自動的に以下を生成
  - `getId()`, `setId()` (ゲッター・セッター)
  - `getTitle()`, `setTitle()`
  - `getContent()`, `setContent()`
  - `toString()`, `equals()`, `hashCode()`
- `@Id`: 主キー（一意識別子）を示す
- `@GeneratedValue(strategy = GenerationType.IDENTITY)`: 
  - データベースが自動的にIDを1, 2, 3...と順番に割り振る

#### オブジェクト指向の観点
- **カプセル化**: フィールドは`private`で隠蔽、アクセスはゲッター・セッターを通じて行う
- **データクラス**: 主にデータを保持する役割（Pure Data Object）

### 2.2 ArticleRepository.java (リポジトリクラス)

```java
public interface ArticleRepository extends JpaRepository<Article, Long> {
}
```

**役割:** データベースとの「窓口」

#### Spring Data JPAの魔法
このインターフェースを継承するだけで、Springが自動的に以下のメソッドを実装してくれます：

```java
// 実際には書いていないが、使えるメソッド
List<Article> findAll()                    // 全件取得
Optional<Article> findById(Long id)        // ID指定で1件取得
Article save(Article article)              // 保存（作成・更新）
void deleteById(Long id)                   // ID指定で削除
long count()                               // 件数取得
boolean existsById(Long id)                // 存在チェック
```

#### オブジェクト指向の観点
- **継承**: `JpaRepository`を継承することで、基本的なCRUD操作を受け継ぐ
- **抽象化**: 具体的なSQL文を書かなくても、メソッド名だけでデータベース操作ができる

### 2.3 ArticleService.java (サービスクラス)

```java
@Service
public class ArticleService {
    @Autowired
    private ArticleRepository articleRepository;
    
    public List<Article> findAllArticles() {
        return articleRepository.findAll();
    }
    
    public Article createArticle(Article article) {
        return articleRepository.save(article);
    }
    
    public Article updateArticle(Long id, Article articleDetails) {
        return articleRepository.save(articleDetails);
    }
    
    public void deleteArticle(Long id) {
        articleRepository.deleteById(id);
    }
}
```

**役割:** ビジネスロジックを処理する「頭脳」

#### アノテーション解説
- `@Service`: 「このクラスはサービス層の処理を担当します」とSpringに伝える
- `@Autowired`: Springが自動的に`ArticleRepository`のインスタンスを注入（DI: Dependency Injection）

#### オブジェクト指向の観点
- **依存性注入**: `ArticleRepository`に依存しているが、自分で`new`しない
- **単一責任原則**: ビジネスロジックのみに集中
- **委譲**: 実際のデータベース操作は`ArticleRepository`に委譲

### 2.4 ArticleController.java (コントローラークラス)

```java
@RequestMapping("/api/articles")
@RestController
public class ArticleController {
    @Autowired
    private ArticleService articleService;
    
    @GetMapping
    public List<Article> getAllArticles() {
        return articleService.findAllArticles();
    }
    
    @PostMapping
    public Article createArticle(@RequestBody Article article) {
        return articleService.createArticle(article);
    }
    
    @PutMapping("/{id}")
    public Article updateArticle(@PathVariable Long id, @RequestBody Article articleDetails) {
        return articleService.updateArticle(id, articleDetails);
    }
    
    @DeleteMapping("/{id}")
    public void deleteArticle(@PathVariable Long id) {
        articleService.deleteArticle(id);
    }
}
```

**役割:** HTTPリクエストを受け取り、適切な処理を行う「受付係」

#### アノテーション解説
- `@RestController`: 「このクラスはREST APIのエンドポイントです」とSpringに伝える
- `@RequestMapping("/api/articles")`: 全てのメソッドのURLに`/api/articles`を前置
- `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`: HTTPメソッドとURLパスを指定
- `@RequestBody`: HTTPリクエストのボディ（JSON）をJavaオブジェクトに変換
- `@PathVariable`: URL内の`{id}`部分を変数として取得

## 3. リクエスト処理の流れ

### 3.1 記事一覧取得 (GET /api/articles)

```
1. ブラウザ → HTTP GET リクエスト → Spring Boot
2. Spring Boot → ArticleController.getAllArticles() 呼び出し
3. ArticleController → ArticleService.findAllArticles() 呼び出し
4. ArticleService → ArticleRepository.findAll() 呼び出し
5. ArticleRepository → データベースにSQLクエリ実行
6. データベース → SELECT * FROM article; の結果を返す
7. ArticleRepository → List<Article> を返す
8. ArticleService → そのまま List<Article> を返す
9. ArticleController → そのまま List<Article> を返す
10. Spring Boot → List<Article> を JSON に変換
11. ブラウザ → JSON レスポンスを受け取る
```

### 3.2 記事作成 (POST /api/articles)

```
1. ブラウザ → HTTP POST リクエスト（JSONデータ付き） → Spring Boot
2. Spring Boot → JSONを Article オブジェクトに変換
3. Spring Boot → ArticleController.createArticle(article) 呼び出し
4. ArticleController → ArticleService.createArticle(article) 呼び出し
5. ArticleService → ArticleRepository.save(article) 呼び出し
6. ArticleRepository → データベースにINSERT文実行
7. データベース → 新しいIDを自動生成して保存
8. ArticleRepository → 保存された Article（IDが設定済み）を返す
9. ArticleService → そのまま Article を返す
10. ArticleController → そのまま Article を返す
11. Spring Boot → Article を JSON に変換
12. ブラウザ → 作成された記事のJSONを受け取る
```

## 4. オブジェクト指向の設計原則

### 4.1 単一責任原則 (Single Responsibility Principle)
- **Article**: データの構造を表現する責任のみ
- **ArticleRepository**: データベースアクセスの責任のみ
- **ArticleService**: ビジネスロジックの責任のみ
- **ArticleController**: HTTPリクエスト処理の責任のみ

### 4.2 依存性逆転の原則 (Dependency Inversion Principle)
- 上位層（Controller）は下位層（Service）の抽象に依存
- 具体的な実装は Spring Framework が注入

### 4.3 開放閉鎖原則 (Open/Closed Principle)
- 新しい機能追加時は、既存コードを変更せずに拡張可能
- 例: 新しいエンドポイントを追加する場合、既存のメソッドは変更不要

## 5. Spring Boot の DI コンテナ

Spring Bootは起動時に以下の処理を自動的に行います：

```
1. @Entity が付いたクラスを探す → Article を発見
2. @Repository が付いたクラスを探す → ArticleRepository を発見
3. @Service が付いたクラスを探す → ArticleService を発見
4. @RestController が付いたクラスを探す → ArticleController を発見
5. 各クラスのインスタンスを作成し、DIコンテナに登録
6. @Autowired を見つけて、適切なインスタンスを注入
```

## 6. メソッド呼び出しの詳細フロー

### 例: 記事作成時の詳細

```java
// 1. フロントエンドから以下のJSONが送信される
{
    "title": "はじめての投稿",
    "content": "こんにちは、世界！"
}

// 2. Spring Boot が自動的に Article オブジェクトを作成
Article article = new Article();
article.setTitle("はじめての投稿");
article.setContent("こんにちは、世界！");
// この時点で article.getId() は null

// 3. ArticleController.createArticle(article) が呼び出される
@PostMapping
public Article createArticle(@RequestBody Article article) {
    // 4. ArticleService に処理を委譲
    return articleService.createArticle(article);
}

// 5. ArticleService.createArticle(article) が呼び出される
public Article createArticle(Article article) {
    // 6. ArticleRepository に処理を委譲
    return articleRepository.save(article);
}

// 7. ArticleRepository.save(article) が呼び出される
// Spring Data JPA が以下のSQL文を自動生成・実行
// INSERT INTO article (title, content) VALUES ('はじめての投稿', 'こんにちは、世界！');

// 8. データベースが新しいIDを自動生成（例: 1）
// 9. ArticleRepository が ID=1 の Article オブジェクトを返す
Article savedArticle = new Article();
savedArticle.setId(1L);
savedArticle.setTitle("はじめての投稿");
savedArticle.setContent("こんにちは、世界！");

// 10. この savedArticle が Service → Controller → Spring Boot → フロントエンド へと順番に返される
```

## 7. まとめ

このアプリケーションは、**関心の分離**という重要な設計原則に基づいて構築されています：

- **Article**: データの構造
- **ArticleRepository**: データの永続化
- **ArticleService**: ビジネスルール
- **ArticleController**: Web API

各層が独立しているため、一つの層を変更しても他の層への影響を最小限に抑えることができます。これが、保守性が高く、拡張しやすいアプリケーションを作る秘訣です。 