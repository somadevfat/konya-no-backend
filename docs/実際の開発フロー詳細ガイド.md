# 🚀 実際の開発フロー詳細ガイド

**作成日時:** 2025年7月9日 16:05:30 JST  
**対象:** 生JDBCアプリケーション開発初心者  
**目標:** どこにどのファイルを作るかを完全理解する

---

## 🎯 **開発の流れ（実際の順序）**

### **実際にやること:**
1. **プロジェクト初期設定** ← まずここから！
2. **データベース設計** ← SQLファイル作成
3. **ドメインクラス作成** ← Plain Javaクラス
4. **データアクセス層** ← 生JDBC実装
5. **ビジネスロジック層** ← サービスクラス
6. **プレゼンテーション層** ← REST API
7. **動作確認・テスト** ← 最後に確認

---

## 📁 **Phase 1: プロジェクト初期設定 (15分)**

### **1.1 build.gradle設定**
**場所:** `build.gradle` (プロジェクトルート)

```gradle
plugins {
	id 'java'
	id 'org.springframework.boot' version '3.5.3'
	id 'io.spring.dependency-management' version '1.1.7'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(17)
	}
}

repositories {
	mavenCentral()
}

dependencies {
	// Spring Boot Web（REST API用）
	implementation 'org.springframework.boot:spring-boot-starter-web'
	
	// Spring Boot JDBC（生JDBC用）
	implementation 'org.springframework.boot:spring-boot-starter-jdbc'
	
	// H2データベース（学習用）
	runtimeOnly 'com.h2database:h2'
	
	// 開発ツール（自動再起動）
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	
	// Swagger UI（API仕様書）
	implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.2.0'
	
	// テスト
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

tasks.named('test') {
	useJUnitPlatform()
}
```

### **1.2 application.properties設定**
**場所:** `src/main/resources/application.properties`

```properties
# アプリケーション名
spring.application.name=simple-spring-rest-api

# H2データベース設定
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# H2コンソール有効化（開発用）
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# サーバーポート
server.port=8080

# JDBCログ表示（デバッグ用）
logging.level.org.springframework.jdbc=DEBUG
```

### **1.3 メインクラス確認**
**場所:** `src/main/java/com/example/simple_spring_rest_api/SimpleSpringRestApiApplication.java`

```java
package com.example.simple_spring_rest_api;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SimpleSpringRestApiApplication {
	public static void main(String[] args) {
		SpringApplication.run(SimpleSpringRestApiApplication.class, args);
	}
}
```

---

## 🗄️ **Phase 2: データベース設計 (30分)**

### **2.1 テーブル設計SQLファイル作成**
**場所:** `src/main/resources/schema.sql`

```sql
-- articlesテーブルの作成
CREATE TABLE IF NOT EXISTS articles (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

**重要ポイント:**
- `AUTO_INCREMENT`: ID自動採番
- `NOT NULL`: 必須項目指定
- `TIMESTAMP`: 日時自動設定

### **2.2 初期データ作成**
**場所:** `src/main/resources/data.sql`

```sql
-- 初期データの投入
INSERT INTO articles (title, content) VALUES 
('はじめての記事', 'これは最初の記事です。'),
('Spring Boot学習', 'Spring Bootの基本を学んでいます。'),
('生JDBC実装', 'JPAを使わずに生JDBCで実装してみました。');
```

---

## 🏗️ **Phase 3: ドメインクラス作成 (30分)**

### **3.1 Articleクラス作成**
**場所:** `src/main/java/com/example/simple_spring_rest_api/domain/Article.java`

**ディレクトリ構造:**
```
src/main/java/com/example/simple_spring_rest_api/
├── domain/           ← ここに作る！
│   └── Article.java  ← 新規作成
├── repository/       ← 次に作るディレクトリ
├── service/          ← その次に作るディレクトリ
└── controller/       ← 最後に作るディレクトリ
```

```java
package com.example.simple_spring_rest_api.domain;

import java.time.LocalDateTime;

/**
 * 記事を表すドメインクラス
 * Plain Javaで実装（Lombokなし）
 */
public class Article {
    
    private Long id;
    private String title;
    private String content;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // デフォルトコンストラクタ
    public Article() {
    }
    
    // 新規作成用コンストラクタ
    public Article(String title, String content) {
        this.title = title;
        this.content = content;
    }
    
    // 全フィールドコンストラクタ
    public Article(Long id, String title, String content, 
                   LocalDateTime createdAt, LocalDateTime updatedAt) {
        this.id = id;
        this.title = title;
        this.content = content;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }
    
    // ゲッター（全フィールド）
    public Long getId() { return id; }
    public String getTitle() { return title; }
    public String getContent() { return content; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    
    // セッター（全フィールド）
    public void setId(Long id) { this.id = id; }
    public void setTitle(String title) { this.title = title; }
    public void setContent(String content) { this.content = content; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
    
    // toString（デバッグ用）
    @Override
    public String toString() {
        return "Article{" +
                "id=" + id +
                ", title='" + title + '\'' +
                ", content='" + content + '\'' +
                ", createdAt=" + createdAt +
                ", updatedAt=" + updatedAt +
                '}';
    }
    
    // equals & hashCode
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Article article = (Article) o;
        return id != null ? id.equals(article.id) : article.id == null;
    }
    
    @Override
    public int hashCode() {
        return id != null ? id.hashCode() : 0;
    }
}
```

**作成のポイント:**
1. **フィールド**: データベーステーブルと同じ構造
2. **コンストラクタ**: 3種類（デフォルト、新規作成用、全フィールド）
3. **ゲッター・セッター**: 全フィールド手動実装
4. **toString**: デバッグ時に便利
5. **equals & hashCode**: IDでの同一性判定

---

## 🗂️ **Phase 4: データアクセス層実装 (60分)**

### **4.1 ArticleRepositoryクラス作成**
**場所:** `src/main/java/com/example/simple_spring_rest_api/repository/ArticleRepository.java`

```java
package com.example.simple_spring_rest_api.repository;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;

import com.example.simple_spring_rest_api.domain.Article;

/**
 * 記事データアクセス用Repository
 * 生JDBCで実装（Spring Data JPAは使用しない）
 */
@Repository
public class ArticleRepository {
    
    private final DataSource dataSource;
    
    @Autowired
    public ArticleRepository(DataSource dataSource) {
        this.dataSource = dataSource;
    }
    
    /**
     * 全記事を取得
     */
    public List<Article> findAll() {
        String sql = "SELECT id, title, content, created_at, updated_at FROM articles ORDER BY id";
        List<Article> articles = new ArrayList<>();
        
        try (Connection connection = dataSource.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql);
             ResultSet resultSet = statement.executeQuery()) {
            
            while (resultSet.next()) {
                Article article = mapResultSetToArticle(resultSet);
                articles.add(article);
            }
            
        } catch (SQLException e) {
            throw new RuntimeException("全記事の取得に失敗しました", e);
        }
        
        return articles;
    }
    
    /**
     * IDによる記事の取得
     */
    public Optional<Article> findById(Long id) {
        String sql = "SELECT id, title, content, created_at, updated_at FROM articles WHERE id = ?";
        
        try (Connection connection = dataSource.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql)) {
            
            statement.setLong(1, id);
            
            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    Article article = mapResultSetToArticle(resultSet);
                    return Optional.of(article);
                }
            }
            
        } catch (SQLException e) {
            throw new RuntimeException("記事の取得に失敗しました。ID: " + id, e);
        }
        
        return Optional.empty();
    }
    
    /**
     * 記事の保存（新規作成）
     */
    public Article save(Article article) {
        String sql = "INSERT INTO articles (title, content, created_at, updated_at) VALUES (?, ?, ?, ?)";
        
        try (Connection connection = dataSource.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            
            LocalDateTime now = LocalDateTime.now();
            
            statement.setString(1, article.getTitle());
            statement.setString(2, article.getContent());
            statement.setTimestamp(3, Timestamp.valueOf(now));
            statement.setTimestamp(4, Timestamp.valueOf(now));
            
            int affectedRows = statement.executeUpdate();
            
            if (affectedRows == 0) {
                throw new RuntimeException("記事の保存に失敗しました");
            }
            
            // 自動生成されたIDを取得
            try (ResultSet generatedKeys = statement.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    article.setId(generatedKeys.getLong(1));
                    article.setCreatedAt(now);
                    article.setUpdatedAt(now);
                } else {
                    throw new RuntimeException("記事の保存に失敗しました。IDが生成されませんでした");
                }
            }
            
        } catch (SQLException e) {
            throw new RuntimeException("記事の保存に失敗しました", e);
        }
        
        return article;
    }
    
    /**
     * 記事の更新
     */
    public Article update(Long id, Article article) {
        String sql = "UPDATE articles SET title = ?, content = ?, updated_at = ? WHERE id = ?";
        
        try (Connection connection = dataSource.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql)) {
            
            LocalDateTime now = LocalDateTime.now();
            
            statement.setString(1, article.getTitle());
            statement.setString(2, article.getContent());
            statement.setTimestamp(3, Timestamp.valueOf(now));
            statement.setLong(4, id);
            
            int affectedRows = statement.executeUpdate();
            
            if (affectedRows == 0) {
                throw new RuntimeException("記事が見つかりません。ID: " + id);
            }
            
            return findById(id).orElseThrow(() -> 
                new RuntimeException("更新後の記事取得に失敗しました。ID: " + id));
            
        } catch (SQLException e) {
            throw new RuntimeException("記事の更新に失敗しました。ID: " + id, e);
        }
    }
    
    /**
     * 記事の削除
     */
    public void deleteById(Long id) {
        String sql = "DELETE FROM articles WHERE id = ?";
        
        try (Connection connection = dataSource.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql)) {
            
            statement.setLong(1, id);
            
            int affectedRows = statement.executeUpdate();
            
            if (affectedRows == 0) {
                throw new RuntimeException("記事が見つかりません。ID: " + id);
            }
            
        } catch (SQLException e) {
            throw new RuntimeException("記事の削除に失敗しました。ID: " + id, e);
        }
    }
    
    /**
     * ResultSetからArticleオブジェクトにマッピング
     */
    private Article mapResultSetToArticle(ResultSet resultSet) throws SQLException {
        Article article = new Article();
        article.setId(resultSet.getLong("id"));
        article.setTitle(resultSet.getString("title"));
        article.setContent(resultSet.getString("content"));
        
        Timestamp createdAt = resultSet.getTimestamp("created_at");
        if (createdAt != null) {
            article.setCreatedAt(createdAt.toLocalDateTime());
        }
        
        Timestamp updatedAt = resultSet.getTimestamp("updated_at");
        if (updatedAt != null) {
            article.setUpdatedAt(updatedAt.toLocalDateTime());
        }
        
        return article;
    }
}
```

**生JDBC実装のポイント:**
1. **@Repository**: Springのリポジトリとして認識
2. **DataSource**: データベース接続管理
3. **try-with-resources**: リソースの自動クローズ
4. **PreparedStatement**: SQLインジェクション対策
5. **mapResultSetToArticle**: 結果セットをオブジェクトに変換

---

## 🔧 **Phase 5: ビジネスロジック層実装 (30分)**

### **5.1 ArticleServiceクラス作成**
**場所:** `src/main/java/com/example/simple_spring_rest_api/service/ArticleService.java`

```java
package com.example.simple_spring_rest_api.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.example.simple_spring_rest_api.domain.Article;
import com.example.simple_spring_rest_api.repository.ArticleRepository;

/**
 * 記事のビジネスロジック処理を担当するServiceクラス
 */
@Service
public class ArticleService {

    private final ArticleRepository articleRepository;

    @Autowired
    public ArticleService(ArticleRepository articleRepository) {
        this.articleRepository = articleRepository;
    }

    /**
     * 全記事を取得
     */
    public List<Article> findAllArticles() {
        return articleRepository.findAll();
    }

    /**
     * IDによる記事の取得
     */
    public Article findArticleById(Long id) {
        return articleRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("記事が見つかりません。ID: " + id));
    }

    /**
     * 記事の作成
     */
    public Article createArticle(Article article) {
        // 入力値の検証
        validateArticle(article);
        
        return articleRepository.save(article);
    }

    /**
     * 記事の更新
     */
    public Article updateArticle(Long id, Article articleDetails) {
        // 入力値の検証
        validateArticle(articleDetails);
        
        // 記事の存在確認
        findArticleById(id);
        
        return articleRepository.update(id, articleDetails);
    }

    /**
     * 記事の削除
     */
    public void deleteArticle(Long id) {
        // 記事の存在確認
        findArticleById(id);
        
        articleRepository.deleteById(id);
    }
    
    /**
     * 記事の入力値検証
     */
    private void validateArticle(Article article) {
        if (article.getTitle() == null || article.getTitle().trim().isEmpty()) {
            throw new IllegalArgumentException("タイトルは必須です");
        }
        if (article.getContent() == null || article.getContent().trim().isEmpty()) {
            throw new IllegalArgumentException("内容は必須です");
        }
    }
}
```

**サービス層のポイント:**
1. **@Service**: Springのサービスとして認識
2. **バリデーション**: 入力値検証
3. **例外処理**: 適切なエラーメッセージ
4. **ビジネスルール**: アプリケーション固有のロジック

---

## 🌐 **Phase 6: プレゼンテーション層実装 (45分)**

### **6.1 ArticleControllerクラス作成**
**場所:** `src/main/java/com/example/simple_spring_rest_api/controller/ArticleController.java`

```java
package com.example.simple_spring_rest_api.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.example.simple_spring_rest_api.domain.Article;
import com.example.simple_spring_rest_api.service.ArticleService;

/**
 * 記事のREST APIエンドポイントを提供するControllerクラス
 */
@RestController
@RequestMapping("/api/articles")
public class ArticleController {

    private final ArticleService articleService;

    @Autowired
    public ArticleController(ArticleService articleService) {
        this.articleService = articleService;
    }

    /**
     * 全記事を取得
     * GET /api/articles
     */
    @GetMapping
    public ResponseEntity<List<Article>> getAllArticles() {
        try {
            List<Article> articles = articleService.findAllArticles();
            return ResponseEntity.ok(articles);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * IDによる記事の取得
     * GET /api/articles/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<Article> getArticleById(@PathVariable Long id) {
        try {
            Article article = articleService.findArticleById(id);
            return ResponseEntity.ok(article);
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * 新しい記事を作成
     * POST /api/articles
     */
    @PostMapping
    public ResponseEntity<Article> createArticle(@RequestBody Article article) {
        try {
            Article createdArticle = articleService.createArticle(article);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdArticle);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().build();
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * 記事を更新
     * PUT /api/articles/{id}
     */
    @PutMapping("/{id}")
    public ResponseEntity<Article> updateArticle(@PathVariable Long id, @RequestBody Article articleDetails) {
        try {
            Article updatedArticle = articleService.updateArticle(id, articleDetails);
            return ResponseEntity.ok(updatedArticle);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().build();
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * 記事を削除
     * DELETE /api/articles/{id}
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteArticle(@PathVariable Long id) {
        try {
            articleService.deleteArticle(id);
            return ResponseEntity.noContent().build();
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}
```

**REST APIのポイント:**
1. **@RestController**: RESTコントローラーとして認識
2. **@RequestMapping**: ベースパス指定
3. **HTTPメソッド**: GET、POST、PUT、DELETE
4. **ResponseEntity**: HTTPステータスコード制御
5. **エラーハンドリング**: 適切な例外処理

---

## ✅ **Phase 7: 動作確認・テスト (30分)**

### **7.1 アプリケーション起動**
```bash
./gradlew bootRun
```

### **7.2 API動作確認**
```bash
# 記事一覧取得
curl -X GET http://localhost:8080/api/articles

# 記事詳細取得
curl -X GET http://localhost:8080/api/articles/1

# 記事作成
curl -X POST http://localhost:8080/api/articles \
  -H "Content-Type: application/json" \
  -d '{"title":"新しい記事","content":"テスト内容"}'

# 記事更新
curl -X PUT http://localhost:8080/api/articles/1 \
  -H "Content-Type: application/json" \
  -d '{"title":"更新された記事","content":"更新された内容"}'

# 記事削除
curl -X DELETE http://localhost:8080/api/articles/1
```

### **7.3 Swagger UI確認**
```
http://localhost:8080/swagger-ui/index.html
```

### **7.4 H2コンソール確認**
```
http://localhost:8080/h2-console
JDBC URL: jdbc:h2:mem:testdb
Username: sa
Password: (空欄)
```

---

## 📂 **最終的なプロジェクト構造**

```
simple-spring-rest-api/
├── build.gradle                               ← ビルド設定
├── src/
│   ├── main/
│   │   ├── java/com/example/simple_spring_rest_api/
│   │   │   ├── SimpleSpringRestApiApplication.java  ← メインクラス
│   │   │   ├── domain/
│   │   │   │   └── Article.java               ← ドメインクラス
│   │   │   ├── repository/
│   │   │   │   └── ArticleRepository.java     ← データアクセス層
│   │   │   ├── service/
│   │   │   │   └── ArticleService.java        ← ビジネスロジック層
│   │   │   └── controller/
│   │   │       └── ArticleController.java     ← プレゼンテーション層
│   │   └── resources/
│   │       ├── application.properties          ← アプリ設定
│   │       ├── schema.sql                     ← テーブル定義
│   │       └── data.sql                       ← 初期データ
│   └── test/
│       └── java/com/example/simple_spring_rest_api/
│           └── SimpleSpringRestApiApplicationTests.java
└── README.md
```

---

## 🎯 **重要なポイント**

### **開発順序を守る理由**
1. **土台から積み上げ**: データベース → ドメイン → リポジトリ → サービス → コントローラー
2. **依存関係**: 上位層は下位層に依存する
3. **テストしやすさ**: 各層を個別にテスト可能

### **各層の役割**
- **Domain**: データ構造の定義
- **Repository**: データベースアクセス
- **Service**: ビジネスロジック
- **Controller**: HTTP通信制御

### **学習のコツ**
1. **まず完全模写**: 理解より手に覚えさせる
2. **段階的理解**: 一度に全部理解しようとしない
3. **実際に動かす**: 必ず動作確認する
4. **エラーを恐れない**: エラーから学ぶ

---

## 🚀 **次のステップ**

1. **User管理システム**を0から作成
2. **Product管理システム**を0から作成
3. **複数テーブルの関連**を実装
4. **より複雑なSQL**を習得

**頑張って！この流れで作れば必ず動くアプリケーションが完成します！** 🎉 