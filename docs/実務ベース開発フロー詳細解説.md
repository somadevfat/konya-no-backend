# 🎯 実務ベース開発フロー詳細解説

**作成日時:** 2025年7月9日 16:16:30 JST  
**対象:** 実務での開発フローを理解したい初心者  
**目標:** なぜその順序で作るのか、データがどう流れるのかを完全理解

---

## 🏢 **実務における開発フロー全体像**

### **実際の開発プロジェクトの流れ**
```
1. 要件定義・分析 (1-2週間)
   ↓
2. システム設計 (1週間)
   ↓
3. 【今回のガイドはここから！】実装フェーズ (2-4週間)
   ↓
4. テスト・デバッグ (1週間)
   ↓
5. デプロイ・運用 (継続)
```

**今回のガイドは「3. 実装フェーズ」の詳細手順です！**

### **要件定義後に決まっていること**
- [ ] **機能要件**: 「記事のCRUD操作ができること」
- [ ] **API仕様**: 「REST APIで提供すること」
- [ ] **データ構造**: 「記事にはタイトル、内容、作成・更新日時が必要」
- [ ] **技術選定**: 「Spring Boot + 生JDBC + H2DB」

---

## 🔄 **データの流れ（リクエスト→レスポンス）**

### **具体例: 記事作成のリクエスト処理**

```
1. ユーザー（ブラウザ/curl）
   ↓ POST /api/articles
   ↓ {"title":"新記事","content":"内容"}
   
2. ArticleController（プレゼンテーション層）
   ↓ createArticle(article)
   ↓ バリデーション・HTTP処理
   
3. ArticleService（ビジネスロジック層）
   ↓ createArticle(article)
   ↓ 入力値検証・ビジネスルール
   
4. ArticleRepository（データアクセス層）
   ↓ save(article)
   ↓ SQL実行・データベース操作
   
5. H2 Database
   ↓ INSERT文実行
   ↓ 新しいIDを生成して返却
   
6. ArticleRepository
   ↓ 生成されたIDを設定したArticleオブジェクト
   
7. ArticleService
   ↓ Articleオブジェクト（バリデーション済み）
   
8. ArticleController
   ↓ ResponseEntity<Article>
   ↓ HTTPステータス201 Created
   
9. ユーザー（ブラウザ/curl）
   ← {"id":4,"title":"新記事","content":"内容",...}
```

---

## 🏗️ **なぜその順序で作るのか？**

### **開発順序の理由**

#### **1. データベース設計から始める理由**
```sql
-- まずテーブル構造を決める
CREATE TABLE articles (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**理由:**
- **データ構造が全ての基盤**になる
- 後からテーブル構造を変更するのは**非常に困難**
- アプリケーションの処理は**データありき**で決まる

#### **2. ドメインクラス（Article.java）を次に作る理由**
```java
public class Article {
    private Long id;           // ← データベースのidと対応
    private String title;      // ← データベースのtitleと対応
    private String content;    // ← データベースのcontentと対応
    // ...
}
```

**理由:**
- **データベースとJavaオブジェクトの橋渡し**
- 他の全てのクラスが**このクラスを使う**
- データの型や制約を**Javaレベルで表現**

#### **3. Repository（データアクセス層）を3番目に作る理由**
```java
@Repository
public class ArticleRepository {
    public Article save(Article article) {
        // SQLでデータベースに保存
        String sql = "INSERT INTO articles (title, content, ...) VALUES (?, ?, ...)";
        // ...
    }
}
```

**理由:**
- **データベース操作の詳細を隠蔽**
- Service層が**SQLを知らなくて良い**
- **データアクセスのテスト**が独立してできる

#### **4. Service（ビジネスロジック層）を4番目に作る理由**
```java
@Service  
public class ArticleService {
    public Article createArticle(Article article) {
        validateArticle(article);        // ← ビジネスルール
        return articleRepository.save(article);  // ← データ操作
    }
}
```

**理由:**
- **ビジネスルールを集約**
- Controller層が**ビジネスロジックを知らなくて良い**
- **複雑な処理の組み合わせ**を管理

#### **5. Controller（プレゼンテーション層）を最後に作る理由**
```java
@RestController
public class ArticleController {
    public ResponseEntity<Article> createArticle(@RequestBody Article article) {
        Article created = articleService.createArticle(article);  // ← Service呼び出し
        return ResponseEntity.status(201).body(created);          // ← HTTP応答
    }
}
```

**理由:**
- **HTTP通信の詳細のみ**を担当
- **全ての下位層が完成済み**なので、テストしやすい
- **APIの仕様変更**に柔軟に対応

---

## 📊 **各層の責任範囲と依存関係**

### **依存関係図**
```
Controller（HTTP制御）
    ↓ 依存
Service（ビジネスロジック）
    ↓ 依存  
Repository（データアクセス）
    ↓ 依存
Database（データ永続化）
```

### **各層の責任**

| 層 | 責任 | やってはいけないこと |
|---|---|---|
| **Controller** | ・HTTP通信制御<br>・リクエスト/レスポンス変換<br>・HTTPステータスコード | ・ビジネスロジック<br>・SQL実行<br>・データベース直接アクセス |
| **Service** | ・ビジネスルール実装<br>・入力値検証<br>・複数Repositoryの組み合わせ | ・HTTP関連処理<br>・SQL詳細<br>・データベース接続管理 |
| **Repository** | ・SQL実行<br>・データベース接続管理<br>・ResultSet⇔Objectマッピング | ・ビジネスロジック<br>・HTTP処理<br>・入力値検証 |
| **Domain** | ・データ構造定義<br>・オブジェクトの同一性判定 | ・ビジネスロジック<br>・データベースアクセス<br>・HTTP処理 |

---

## 🔍 **具体的なコード実行の流れ**

### **例: GET /api/articles/1 の処理**

#### **1. ControllerでHTTPリクエストを受信**
```java
@GetMapping("/{id}")
public ResponseEntity<Article> getArticleById(@PathVariable Long id) {
    // ↓ ここでServiceに処理を委譲
    Article article = articleService.findArticleById(id);
    return ResponseEntity.ok(article);
}
```

#### **2. ServiceでビジネスロジックとRepositoryへの委譲**
```java
public Article findArticleById(Long id) {
    // ↓ ここでRepositoryに処理を委譲
    return articleRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("記事が見つかりません。ID: " + id));
}
```

#### **3. RepositoryでSQL実行**
```java
public Optional<Article> findById(Long id) {
    String sql = "SELECT id, title, content, created_at, updated_at FROM articles WHERE id = ?";
    
    try (Connection connection = dataSource.getConnection();
         PreparedStatement statement = connection.prepareStatement(sql)) {
        
        statement.setLong(1, id);  // ← パラメータ設定
        
        try (ResultSet resultSet = statement.executeQuery()) {
            if (resultSet.next()) {
                // ↓ ResultSetからArticleオブジェクトに変換
                Article article = mapResultSetToArticle(resultSet);
                return Optional.of(article);
            }
        }
    }
    return Optional.empty();
}
```

#### **4. データベースからの結果をオブジェクトに変換**
```java
private Article mapResultSetToArticle(ResultSet resultSet) throws SQLException {
    Article article = new Article();
    article.setId(resultSet.getLong("id"));              // ← DB: id → Java: Long
    article.setTitle(resultSet.getString("title"));       // ← DB: title → Java: String  
    article.setContent(resultSet.getString("content"));   // ← DB: content → Java: String
    
    Timestamp createdAt = resultSet.getTimestamp("created_at");
    if (createdAt != null) {
        article.setCreatedAt(createdAt.toLocalDateTime()); // ← DB: TIMESTAMP → Java: LocalDateTime
    }
    
    return article;  // ← 完成したArticleオブジェクト
}
```

---

## 🧭 **実際のデバッグ手順**

### **問題発生時の調査順序**
```
1. Controller層をチェック
   ↓ HTTPステータス・リクエスト/レスポンス形式
   
2. Service層をチェック  
   ↓ ビジネスロジック・バリデーション
   
3. Repository層をチェック
   ↓ SQL文・データベース接続
   
4. Database層をチェック
   ↓ テーブル構造・データ内容
```

### **各層でのデバッグ方法**

#### **Controller層のデバッグ**
```java
@PostMapping
public ResponseEntity<Article> createArticle(@RequestBody Article article) {
    System.out.println("受信したリクエスト: " + article);  // ← デバッグ出力
    try {
        Article created = articleService.createArticle(article);
        System.out.println("作成された記事: " + created);    // ← デバッグ出力
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    } catch (Exception e) {
        System.out.println("エラー発生: " + e.getMessage()); // ← エラー出力
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
    }
}
```

#### **Repository層のデバッグ**
```java
public Article save(Article article) {
    String sql = "INSERT INTO articles (title, content, created_at, updated_at) VALUES (?, ?, ?, ?)";
    System.out.println("実行SQL: " + sql);                    // ← SQL確認
    System.out.println("パラメータ: " + article.getTitle());   // ← パラメータ確認
    
    try (Connection connection = dataSource.getConnection();
         PreparedStatement statement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
        
        // SQL実行...
        int affectedRows = statement.executeUpdate();
        System.out.println("影響行数: " + affectedRows);        // ← 実行結果確認
    }
}
```

---

## 🎯 **開発順序のメリット**

### **1. 段階的テスト可能**
```
Phase 1: Repositoryのテスト
→ データベースCRUDが正常動作することを確認

Phase 2: Serviceのテスト  
→ Repositoryを使ったビジネスロジックが正常動作することを確認

Phase 3: Controllerのテスト
→ Serviceを使ったHTTP APIが正常動作することを確認
```

### **2. 責任範囲が明確**
- **問題発生時に調査範囲を絞れる**
- **各層を独立して修正可能**
- **チーム開発時に作業分担しやすい**

### **3. 拡張性が高い**
- **Repository層だけJPA→MyBatisに変更可能**
- **Controller層だけGraphQL対応追加可能**
- **Service層だけビジネスルール追加可能**

---

## 💡 **学習時の重要ポイント**

### **模写時に意識すること**
1. **「なぜこのメソッドを呼んでいるのか？」**を考える
2. **「このデータはどこから来てどこに行くのか？」**を追跡する
3. **「このクラスの責任は何なのか？」**を理解する
4. **「エラーが発生したらどの層で発生するのか？」**を想像する

### **実際の練習方法**
```java
// 悪い例：理解せずに模写
public Article createArticle(Article article) {
    return articleRepository.save(article);  // ← なぜsaveを呼ぶのか理解していない
}

// 良い例：流れを理解して模写
public Article createArticle(Article article) {
    // 1. 入力値検証（Service層の責任）
    validateArticle(article);
    
    // 2. データベース保存（Repository層に委譲）
    return articleRepository.save(article);
    
    // 戻り値: 保存されたArticle（IDが設定済み）
}
```

### **デバッグスキル向上**
1. **各層にデバッグ出力を入れる**
2. **H2コンソールでSQLを直接確認**
3. **Swagger UIでAPIを実際に叩く**
4. **ログを見てエラーの発生箇所を特定**

---

## 🎖️ **実務レベルの理解チェック**

### **チェックリスト**
- [ ] HTTPリクエストからデータベース更新までの流れを説明できる
- [ ] 各層の責任範囲を説明できる
- [ ] なぜその順序で開発するのかを説明できる
- [ ] エラーが発生した時にどの層で調査するかわかる
- [ ] 新機能追加時にどのクラスを修正するかわかる

### **実践課題**
1. **User管理システム**を同じ順序で作成
2. **エラーハンドリング**を各層に追加
3. **ログ出力**を各層に追加
4. **複数テーブル**の関連を実装

---

## 🚀 **まとめ**

### **開発順序の本質**
1. **依存関係**: 下位層→上位層の順番で作る
2. **責任分離**: 各層が自分の責任のみ持つ
3. **テスト容易性**: 段階的に動作確認できる
4. **保守性**: 問題箇所を特定しやすい

### **データフローの本質**
1. **外部→内部**: HTTPリクエスト→ビジネスロジック→データベース
2. **内部→外部**: データベース→ビジネスロジック→HTTPレスポンス
3. **各層での変換**: HTTP形式⇔Javaオブジェクト⇔SQL形式

**この理解があれば、模写が「意味のある学習」になります！** 🎯 