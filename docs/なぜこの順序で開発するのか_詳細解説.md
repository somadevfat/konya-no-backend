# 🏗️ なぜこの順序で開発するのか？【Java Silver合格者向け 深掘り解説】

**作成日時:** 2025年7月9日 16:42:45 JST  
**対象:** Java Silverを取得し、次のステップに進みたい方  
**目標:** 各開発ステップの「なぜ？」を完全に理解し、模写から脱却する

---

## 🔑 **はじめに：なぜ「順序」が重要なのか？**

Java Silverではクラスやインターフェース、継承などを学びました。しかし、それらをどう組み合わせて「動くアプリケーション」を作るかは学びません。

実務での開発は、**依存関係**を意識して、**土台から順番に**作っていくのが鉄則です。家を建てる時、屋根から作らないのと同じです。

このガイドでは、各ステップを「家づくり」に例えて、その**必要不可欠な理由**を解説します。

---

## **Phase 1: データベース設計 (家の設計図と土地)**

### **やること：テーブル定義 (schema.sql) を作る**
```sql
CREATE TABLE articles (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL
);
```

### **【最重要】なぜ、これから始めるのか？**
アプリケーションが扱う**「データ」そのものを定義する**からです。データはアプリケーションの**心臓部**であり、全ての機能の土台（土地と設計図）になります。

- **理由1：全ての機能がデータに依存するから**
  - 「記事を保存する」「記事を表示する」といった機能は、そもそも「記事」というデータがどんな形（タイトル、内容など）なのか決まっていなければ実装できません。
  - 設計図なしに家を建て始められないのと同じです。

- **理由2：後からの変更コストが非常に高いから**
  - 一度建てた家の間取りを変えるのが大変なように、一度決めたテーブル構造を後から変更するのは非常に困難で、多くのバグの原因になります。
  - 例えば、後から`title`の文字数制限を`VARCHAR(100)`に変えた場合、すでに入っている100文字以上のデータはどうするのか？といった問題が発生します。

### **Java Silver知識との関連**
- `BIGINT`, `VARCHAR`, `TEXT`は、Javaで学んだ`long`, `String`などの**データ型**のデータベース版です。データベースに「どんな型のデータが入るか」を厳密に定義しています。
- `PRIMARY KEY`, `NOT NULL`は**制約**です。Javaのコードで言えば「このフィールドはnullであってはならない」というルールを、データベースレベルで強制するものです。

### **これをやらないと、どうなる？**
- 各機能で扱うデータの形がバラバラになり、整合性が取れなくなる。
- 開発の途中で「やっぱり記事に投稿者IDが必要だった！」となり、関連する全てのクラスの修正が必要になる。（＝**大規模な手戻り**が発生する）
- どんなデータが必要か不明確なため、次のステップ（ドメインクラス作成）に進めない。

---

## **Phase 2: ドメインクラス作成 (家の建築資材)**

### **やること：Article.java を作る**
```java
public class Article {
    private Long id;
    private String title;
    private String content;
    // getter/setter...
}
```

### **なぜ、2番目にこれを作るのか？**
データベース（設計図）で定義したデータを、**Javaの世界で扱うための「型」を作る**ためです。これは、設計図に基づいてコンクリートブロックや柱などの**建築資材**を用意する工程に似ています。

- **理由1：プログラム内でデータを一塊として扱えるようにするため**
  - `title`や`content`をバラバラの変数で受け渡すのではなく、`Article`という一つのオブジェクトにまとめて扱うことで、コードが整理され、間違いが減ります。
  - これはJava Silverで学んだ「オブジェクト指向」の基本です。関連するデータを一つのクラスにまとめることで、カプセル化が実現できます。

- **理由2：これ以降の全てのJavaコードがこのクラスを利用するから**
  - `Repository`は`Article`をDBに保存し、`Service`は`Article`のビジネスルールを処理し、`Controller`は`Article`を外部とやり取りします。まさに「建築資材」です。

### **Java Silver知識との関連**
- これは**POJO (Plain Old Java Object)** と呼ばれ、Java Silverで学んだ**クラスそのもの**です。`private`なフィールドと`public`なgetter/setterを持つ、最も基本的なクラスの形です。
- フレームワークの特殊な機能に依存せず、Javaの基本だけで成り立っています。

### **これをやらないと、どうなる？**
- データベースから取得したデータを格納する「受け皿」がない。
- 各クラスで`String title`, `String content`などをバラバラに管理する必要があり、メソッドの引数が増え、コードが非常に汚くなる。
- Javaの強力な型システムの恩恵を受けられない。

---

## **Phase 3: Repository層の実装 (専門の建設作業員)**

### **やること：ArticleRepository.java を作る**
```java
@Repository
public class ArticleRepository {
    public Article save(Article article) {
        // 生JDBCコードでDBにINSERT文を実行
    }
}
```

### **なぜ、3番目にこれを作るのか？**
データベース（土地）とJavaオブジェクト（建築資材）の**具体的な橋渡し役**を作るためです。これは、設計図を読んで、資材を使い、実際に建設作業を行う**専門の作業員（大工、左官など）**に相当します。

- **理由1：データベース操作の「やり方」を１箇所に集めるため**
  - SQL文を書いたり、`Connection`や`PreparedStatement`を管理したりといった、面倒で間違いやすい処理をこのクラスに**全て押し込めます**。
  - これにより、他のクラス（特にService層）は、**どうやって**データベースに保存するかを気にする必要がなくなり、「`articleRepository.save(article)`を呼び出せば保存される」とだけ考えればよくなります。これを**関心の分離**と言います。

### **Java Silver知識との関連**
- `Connection`, `PreparedStatement`, `ResultSet`は、Java SEに含まれる**JDBC API**です。Java Silverの範囲外かもしれませんが、Javaの標準的なデータベース接続機能です。
- `try-with-resources`構文は、Java Silverの例外処理で学びます。リソースの自動クローズに必須の知識です。
- メソッド（例: `save`）が引数として`Article`オブジェクトを受け取り、その中身（`article.getTitle()`など）を使って処理を行う、という流れはJavaの基本です。

### **これをやらないと、どうなる？**
- アプリケーションの様々な場所にSQL文が散らばってしまう。
- もしデータベースの種類を変更（例: H2→MySQL）した場合、散らばった全てのSQLを修正する必要があり、現実的ではない。
- ビジネスロジックとデータベースアクセス処理が混ざり合い、コードが非常に複雑で読みにくくなる。

---

## **Phase 4: Service層の実装 (現場監督)**

### **やること：ArticleService.java を作る**
```java
@Service
public class ArticleService {
    public Article createArticle(Article article) {
        // ビジネスロジック（例：タイトルの文字数チェック）
        if (article.getTitle().length() > 100) {
            throw new IllegalArgumentException("タイトルが長すぎます");
        }
        // Repositoryを呼び出して保存
        return articleRepository.save(article);
    }
}
```

### **なぜ、4番目にこれを作るのか？**
アプリケーションの**「ビジネスルール」や「処理の流れ」を制御する司令塔**を作るためです。これは、複数の作業員（Repository）に指示を出し、建設プロジェクト全体を管理する**現場監督**の役割です。

- **理由1：ビジネスロジックを１箇所に集めるため**
  - 「記事を作成する前に入力内容をチェックする」「ユーザーが有料会員でなければ記事を保存できない」といった、アプリケーション固有のルールをここに実装します。
  - これにより、ControllerはHTTPの処理に、RepositoryはDB操作にそれぞれ専念できます。

- **理由2：複数のデータベース操作を組み合わせるため**
  - 例えば、「記事を保存し、同時に著者の投稿数を更新する」といった場合、`articleRepository.save()`と`userRepository.update()`の２つをこの層で呼び出します。現場監督が複数の作業員に指示を出すのと同じです。

### **Java Silver知識との関連**
- `if`文による条件分岐、例外（`IllegalArgumentException`）のスローなど、Java Silverで学んだ**制御構文や例外処理**がビジネスロジックの核となります。
- `ArticleRepository`をフィールドとして持ち（**依存性の注入**）、そのメソッドを呼び出す、というクラス間の連携はオブジェクト指向の基本です。

### **これをやらないと、どうなる？**
- ビジネスロジックがController層やRepository層に漏れ出してしまう。
- Controllerにロジックを書くと、同じロジックを別の場所（例: バッチ処理）で再利用できなくなる。
- コードのどこに重要なビジネスルールが書かれているのか分からなくなり、保守が非常に困難になる。

---

## **Phase 5: Controller層の実装 (受付・広報担当)**

### **やること：ArticleController.java を作る**
```java
@RestController
@RequestMapping("/api/articles")
public class ArticleController {
    @PostMapping
    public ResponseEntity<Article> createArticle(@RequestBody Article article) {
        // Serviceを呼び出してビジネスロジックを実行
        Article createdArticle = articleService.createArticle(article);
        // 結果をHTTPレスポンスとして返す
        return ResponseEntity.status(HttpStatus.CREATED).body(createdArticle);
    }
}
```

### **なぜ、最後にこれを作るのか？**
アプリケーションの**外部からの窓口**を作るためです。家が完成した後、訪問者（ユーザー）を迎え入れる**受付や玄関**を設置するようなものです。

- **理由1：外部とのやり取りに専念するため**
  - ユーザーからのHTTPリクエストを受け取り、それをJavaオブジェクト（`Article`）に変換し、Service層に渡すのが主な仕事です。
  - Service層から返ってきた結果を、今度はHTTPレスポンス（JSON形式など）に変換してユーザーに返します。
  - これにより、アプリケーション内部の複雑な処理を外部から完全に隠蔽できます。

- **理由2：全ての内部機能が完成している必要があるから**
  - 訪問者を案内するためには、案内先の部屋（Service層以下の機能）が全て完成している必要があります。そのため、この層は最後に作られます。

### **Java Silver知識との関連**
- `@RestController`や`@PostMapping`などの**アノテーション**は、Java Silverで学ぶメタデータの概念です。この記述があることで、Springフレームワークが「このメソッドはPOSTリクエストの`/api/articles`というURLに対応する」と解釈してくれます。
- メソッドの引数で`Article`オブジェクトを受け取り、戻り値として`ResponseEntity<Article>`を返す、という部分はJavaのメソッド定義そのものです。

### **これをやらないと、どうなる？**
- アプリケーションは内部で完結しており、外部（ブラウザや他のシステム）から一切利用できない。
- どんなに素晴らしい機能も、ユーザーに届ける手段がないため、無価値になってしまう。

---

## 🎖️ **まとめ：なぜこの順序なのか？**

**依存関係のピラミッド**をイメージしてください。

```
      Controller  （受付：Serviceに依存）
         ↑
       Service    （監督：Repositoryに依存）
         ↑
      Repository  （作業員：DomainとDBに依存）
         ↑
Domain & Database （資材と設計図：誰にも依存しない）
```

- **土台から作る**: 誰にも依存しない**データベース**と**ドメイン**から作らなければ、その上には何も建てられません。
- **責任を分離する**: 各層が自分の仕事に専念することで、コードは**読みやすく**、**テストしやすく**、**変更に強く**なります。これがモダンなアプリケーション開発の基本思想です。

この「なぜ？」を理解すれば、あなたはもうただの模写をする人ではありません。**設計思想を理解したエンジニア**への第一歩を踏み出したことになります。 